#LyX 1.6.9 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{hyperref}
\end_preamble
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 0
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
(Clojure (for the masses))
\end_layout

\begin_layout Date
(date 
\begin_inset Quotes eld
\end_inset

27.03.2011
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Author
(author 
\begin_inset Quotes eld
\end_inset

Tero Kadenius
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

Tarmo Aidantausta
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
This seminar paper introduces Clojure, a dialect of Lisp, which is a dynamically
 typed functional programming language hosted on virtual machines like JVM
 and CLR.
\end_layout

\begin_layout Standard
The key point that makes Clojure stand out in the pool of new and fancy
 programming languages is the fact it has been developed from the ground
 up with multithreaded programming in mind.
 
\emph on
Immutable data structures
\emph default
, support for 
\emph on
software transactional memory
\emph default
 (STM) with the combination of 
\emph on
functional programming
\emph default
 paradigm give Clojure good tools working with concurrency.
 
\begin_inset CommandInset citation
LatexCommand cite
key "kraus-2009"

\end_inset


\end_layout

\begin_layout Standard
Even though concurrency had an emphasis in designing Clojure it is still
 a general purpose language with interoperability features to leverage the
 functionality and the ecosystem of the host platform, so it's possible
 to reuse already existing code and libraries done for the host platform.
 
\begin_inset CommandInset citation
LatexCommand cite
key "cloj-rationale,cloj-java-interop"

\end_inset


\end_layout

\begin_layout Standard
The paper gives first a short tour to very basics of Clojure and dives into
 further details of the language and its features.
\end_layout

\begin_layout Subsection
Dialect of Lisp
\end_layout

\begin_layout Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(= 2 (+ 1 1))
\end_layout

\end_inset


\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

Lisp is a family of computer programming languages based on formal functional
 calculus.
 Lisp (for "List Processing Language") stores and manipulates programs in
 the same manner as any other data, making it well suited for "meta-programming"
 applications.
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "lisp-wikiquote"

\end_inset


\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

Lisp has jokingly been called "the most intelligent way to misuse a computer".
 I think that description is a great compliment because it transmits the
 full flavor of liberation: it has assisted a number of our most gifted
 fellow humans in thinking previously impossible thoughts.
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "dijkstra-1972"

\end_inset


\end_layout

\begin_layout Subsection
Dynamic typing
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

In a
\emph on
 dynamically typed 
\emph default
language, values have fixed types, but variables and expressions have no
 fixed types.
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "watt-04"

\end_inset


\end_layout

\begin_layout Subsection
Functional programming
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

In functional programming, the model of computation is the application of
 functions to arguments.
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "watt-04"

\end_inset


\end_layout

\begin_layout Section
Introduction to Clojure syntax
\end_layout

\begin_layout Standard
To make it easier to read this paper parts of the syntax of Clojure are
 introduced here with simple shortly explained examples.
 There are a lot of concepts that are not explained but will be explained
 later in the article.
\end_layout

\begin_layout Subsection
Lispy syntax
\end_layout

\begin_layout Standard
Lisps, like Clojure, don't have a lot of syntax in the traditional sense
 of syntax, compared to languages like Java, C or C++.
 The syntax is minimized to mainly into defining lists with parenthesis
 and the different rules of evaluations of those lists.
\end_layout

\begin_layout Subsubsection
Parentheses, parentheses, parentheses
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename lisp_cycles.png
	width 55page%

\end_inset


\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

These are your father's parentheses.
 Elegant weapons, for a more...
 civilized age.
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "xkcd-297"

\end_inset


\end_layout

\begin_layout Standard
As Lisps are about lists - the name LISP derives from "LISt Processing"
 
\begin_inset CommandInset citation
LatexCommand cite
key "mccarthy-1960"

\end_inset

, and lists in Lisps are about parentheses.
 This means that in Clojure reading and writing parentheses is inevitable.
 A lot has been said about the amount of parentheses in Lisps, both good
 and bad.
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

Lisp has all the visual appeal of oatmeal with fingernail clippings mixed
 in.
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "wall-1996"

\end_inset


\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

...and here I thought it was LotsofInfernalStupidParentheses.
 My mistake; I must have just been in a worse mood.
 ;->
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "c2-lisp-folk"

\end_inset


\end_layout

\begin_layout Subsubsection
Lists
\end_layout

\begin_layout Standard
In Clojure, as in all the Lisps, the lists have special syntax to them which
 is due to the homoiconicity - code is data and data is code.
 This might seem confusing at first but the rules are quite simple although
 they overload the definition of lists a bit.
\end_layout

\begin_layout Standard
Below we can see a list which evaluates to a function call to + with 1,
 2, and 3 as parameters to that function.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(+ 1 2 3)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Below is a definition of list with numbers.
 Quote in the beginning of the line tells the compiler that it should treat
 the following list just as data.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

'(+ 1 2 3)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Below we can see how a list can be also constructed with a function call
 to a list.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(list + 1 2 3)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Prefix vs.
 infix notation
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

Polish notation, also known as prefix notation, is a form of notation for
 logic, arithmetic, and algebra.
 Its distinguishing feature is that it places operators to the left of their
 operands.
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "wiki-polish"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

+ 1 2
\end_layout

\end_inset


\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

Infix notation is the common arithmetic and logical formula notation, in
 which operators are written infix-style between the operands they act on
 (e.g.
 2 + 2).
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-infix"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

1 + 2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Clojure, as all Lisps, uses prefix notation in contrast to infix notation
 is which used in languages like C, C++ and Java.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-polish,wiki-infix"

\end_inset


\end_layout

\begin_layout Subsubsection
Defining functions
\end_layout

\begin_layout Standard
Functions are first-class objects in Clojure and there is more than one
 way of defining them.
\begin_inset CommandInset citation
LatexCommand cite
key "cloj-functional"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(def hai (fn [] "Ou hai!"))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Above we define a function that returns string 
\begin_inset Quotes eld
\end_inset

Ou hai!
\begin_inset Quotes erd
\end_inset

 by using
\emph on
 macros 
\emph default
called
\emph on
 fn
\emph default
 and 
\emph on
def
\emph default
.
 
\emph on
fn
\emph default
 that creates the function takes names and the default values for parameters
 inside [] as the first parameter and the body of the function as the second
 parameter.
\begin_inset CommandInset citation
LatexCommand cite
key "cloj-core-api"

\end_inset

A macro called 
\emph on
def
\emph default
 binds a the name with a value.
\begin_inset CommandInset citation
LatexCommand cite
key "cloj-core-api"

\end_inset


\end_layout

\begin_layout Standard
You can also define functions with a 
\emph on
macro
\emph default
 called 
\emph on
defn
\emph default
.
 
\begin_inset CommandInset citation
LatexCommand cite
key "cloj-functional"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(defn hai-u [u]
\end_layout

\begin_layout Plain Layout

  (str "Hai, " u))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That 
\emph on
macro
\emph default
 takes the name, optionally a document string and attribute map, parameters
 and the function body as parameters.
\begin_inset CommandInset citation
LatexCommand cite
key "cloj-core-api"

\end_inset


\end_layout

\begin_layout Standard
You can also use a Clojures dispatch macro to create a function.
 
\begin_inset CommandInset citation
LatexCommand cite
key "cloj-reader"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(def hai-u2 #(str "Hai, " %1 " and " %2))
\end_layout

\end_inset


\end_layout

\begin_layout Section
Functional vs.
 imperative programming
\end_layout

\begin_layout Subsection
Imperative programming
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

Imperative programming is a programming paradigm that describes computation
 in terms of statements that change a program state.
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "wiki-imp-prg"

\end_inset


\end_layout

\begin_layout Standard
Nearly all machine code implementations are written in imperative style.
 The contents of the memory holds the state and machine language instructions
 modify it.
 Higher-level imperative languages have more advanced features like variables
 and complex statements, but the basic idea remains the same.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-imp-prg"

\end_inset


\end_layout

\begin_layout Standard
Here is a small snippet of imperative code.
 It has a notion of state (a), which is mutated.
 In addition, an IO operation is performed.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int a = 3; 
\end_layout

\begin_layout Plain Layout

int b = 4;
\end_layout

\begin_layout Plain Layout

if (a < b) {
\end_layout

\begin_layout Plain Layout

	a++;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

print(a);
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Object oriented programming
\end_layout

\begin_layout Quotation
"The set of values of the attributes of a particular object is called its
 state.
 The object consists of state and the behavior that's defined in the object's
 classes." 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-oo"

\end_inset

 
\end_layout

\begin_layout Standard
Object oriented programming provides a feature called encapsulation.
 Encapsulation prevents users of the object from direcly modifying the data
 that forms the state by providing operations (methods) for doing it.
 This is done in order to ensure the validity of the internal state of the
 object.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-oo-enc"

\end_inset


\end_layout

\begin_layout Standard
In other words, at its heart, object oriented programming tends to be imperative.
 The paradigm itself doesn't enforce it, but that is usually the case.
 
\begin_inset CommandInset citation
LatexCommand cite
key "cloj-state"

\end_inset


\end_layout

\begin_layout Standard
An example that demonstrates the imperative nature of OO code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Foo {
\end_layout

\begin_layout Plain Layout

    int a = 3;
\end_layout

\begin_layout Plain Layout

	int b = 4;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    increment() {
\end_layout

\begin_layout Plain Layout

        if (a < b) {
\end_layout

\begin_layout Plain Layout

		    a++;	
\end_layout

\begin_layout Plain Layout

 	   }
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	print() {
\end_layout

\begin_layout Plain Layout

		print(a);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	....
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
What happens here is identical to the imperative code example except that
 in this case the data (a and b) and the operations mutating the state (a++)
 or causing other side effects (print(a) ) are encapsulated inside the object.
 
\end_layout

\begin_layout Standard
increment() is an instruction for modifying the state of the object.
 The result of increment() may vary in different points of time depending
 on the state of the object.
\end_layout

\begin_layout Subsection
Functional programming
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

Functional programming has its roots in mathematics.
 Instead of providing instructions for modifying the state of the program,
 functional programming emphasizes the application of functions and avoid
 state and mutable data in general.
 
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "wiki-func"

\end_inset

 
\end_layout

\begin_layout Subsubsection
Functions as first class objects
\end_layout

\begin_layout Standard
The notion of a function is not unique to functional programming languages.
 However, functional languages have what is called 
\emph on
first class functions
\emph default
.
 This means that functions have a central role in the code, much like objects
 do in OO languages.
 Functions can be stored to data structures and the use of 
\emph on
higher-order functions
\emph default
 is common.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-1st-class-fn"

\end_inset

 The objective of having no side effects manifests itself in 
\emph on
pure functions
\emph default
.
 
\end_layout

\begin_layout Standard
Function is considered pure if:
\end_layout

\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset

The function always evaluates the same result value given the same argument
 value(s).
 The function result value cannot depend on any hidden information or state
 that may change as program execution proceeds or between different executions
 of the program, nor can it depend on any external input from I/O devices.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-pure-fn"

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset

Evaluation of the result does not cause any semantically observable side
 effect or output, such as mutation of mutable objects or output to I/O
 devices.
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-pure-fn"

\end_inset


\end_layout

\begin_layout Standard
Using pure functions has several benefits: 
\end_layout

\begin_layout Enumerate
Pure expression can be removed without affecting other expressions if the
 result of the pure expression is not used.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-func"

\end_inset

 
\end_layout

\begin_layout Enumerate

\emph on
Referential transparency
\emph default
.
 An expression can be replaced with its value without causing changes to
 the program.
 The output is always the same with the same input.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-reftrans"

\end_inset


\end_layout

\begin_layout Enumerate
If a pure function does not depend on the result of another pure function,
 they can be performed in any order.
 Ie.
 they are thread-safe and can be run in parallel without typical concurrency
 issues.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-func"

\end_inset

 
\end_layout

\begin_layout Enumerate
Lack of side effects guaranteed by the language, provides opportunities
 for compiler optimizations.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-func"

\end_inset

 
\end_layout

\begin_layout Subsubsection
Higher-order functions
\end_layout

\begin_layout Standard
Higher-order function is a function that either takes one or more functions
 as parameters or returns one as a value.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-higher-fn"

\end_inset

 Well-known examples of higher-order functions are 
\emph on
map
\emph default
 and 
\emph on
fold
\emph default
 
\shape italic

\begin_inset CommandInset citation
LatexCommand cite
key "wiki-fold"

\end_inset

.

\shape default
 
\begin_inset Quotes eld
\end_inset

Map is the name of a higher-order function that applies a given function
 element-wise to a list of elements and returns a list of results.
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-map"

\end_inset

.
 Fold is a 
\begin_inset Quotes eld
\end_inset

function that iterate an arbitrary function over a data structure in some
 order and build up a return value
\begin_inset Quotes erd
\end_inset

.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-fold"

\end_inset


\end_layout

\begin_layout Itemize
Doubling the value of every element in a list using map:
\emph on

\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(map (fn [x] (* 2 x)) '(1 2 3))
\end_layout

\end_inset

=> ((* 2 1) (* 2 2) (* 2 3)) => (2 4 6)
\begin_inset Newline newline
\end_inset

infix notation equivalent: (2 * 1) (2 * 2)(2 * 3)
\end_layout

\begin_layout Itemize
In Clojure fold is called reduce.
 A trivial example for calculating the sum of the elements in a list: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(reduce + '(1 2 3))
\end_layout

\end_inset


\emph on
=> (+ (+1 2) 3) => 6
\begin_inset Newline newline
\end_inset

infix notation equivalent: (1+2) + 3
\end_layout

\begin_layout Subsubsection*
Partial function application and currying
\end_layout

\begin_layout Standard
Higher-order functions enable an interesting feature where a new function
 can be generated based on another function.
 
\emph on
Partial function application
\emph default
 is a technique which produces a function in which one or more of the arguments
 of the original function are fixed.
 
\emph on
Currying
\emph default
 resembles partial function application.
 The difference is that in currying each (curried) function takes only a
 single argument and produces a function which takes one argument less than
 its predecessor.
 Ie.
 currying produces a chain of functions, whereas with partial function applicati
on arbitrary number of functions can be fixed at once.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-curry"

\end_inset

 
\end_layout

\begin_layout Standard
Out of the box, Clojure supports partial function application but not currying.
 
\end_layout

\begin_layout Standard
A simple example where a function that adds 2 to its argument is applied
 to a list of elements:
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(map(partial + 2) '(1 2 3))
\end_layout

\end_inset


\emph on
 => ((+ 2 1)(+ 2 2)(+ 3 3))=> (3 5 7)
\begin_inset Newline newline
\end_inset

infix notation equivalent: ((2 + 1)(2 + 2)(2 + 3))
\end_layout

\begin_layout Subsection
Differences
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features islongtable="true">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row endhead="true">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Characteristic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Imperative approach
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Functional approach
\end_layout

\end_inset
</cell>
</row>
<row endfirsthead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Programmer focus
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
How to perform tasks (algorithms) and how to track changes in state.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
What information is desired and what transformations are required.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
State changes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Important.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Non-existent.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Order of execution
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Important.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Low importance.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Primary flow control
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Loops, conditionals, and function (method) calls.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Function calls, including recursion.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Primary manipulation unit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instances of structures or classes.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Functions as first-class objects and data collections.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand cite
key "msdn-func-imp"

\end_inset


\end_layout

\begin_layout Subsection
Critique
\end_layout

\begin_layout Standard
The proponents of functional programming claim that imperative programming
 is fundamentally broken - especially in a multi-threaded environment.
 First of all, there is an argument that the world doesn't function in a
 way imperative programming models it.
 When dealing with mutable state, the "world" has to stop in order it be
 examined or changed.
 This becomes a major problem when bringing concurrent programming to the
 picture.
 
\begin_inset CommandInset citation
LatexCommand cite
key "cloj-state"

\end_inset


\end_layout

\begin_layout Standard
OO programming suffers from the same problems as imperative programming.
 To quote Rich Hickey, the creator of Clojure: "Encapsulation just means:
 I'm in charge of this spaghetti code." Ie.
 encapsulation doesn't change the fact that OO is usually based on mutable
 state.
 It just tries to prevent the user of object's interface from seeing it
 (the (imperative) spaghetti code).
\end_layout

\begin_layout Section
Closer look at Clojure
\end_layout

\begin_layout Standard
Now that the paradigm of functional programming has been familiriazed, a
 closer look at Closures features and terminology is in place.
\end_layout

\begin_layout Subsection
Syntax
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

Like most other Lisps, Clojure's syntax is built on S-expressions that are
 first parsed into data structures by a reader before being compiled.
 Clojure's reader supports literal syntax for maps, sets and vectors in
 addition to lists, and these are given to the compiler as they are.
 In other words, the Clojure compiler does not compile only list data structures
, but supports all of the mentioned types directly.
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-clojure"

\end_inset


\end_layout

\begin_layout Section
Concurrency/parallelism in Clojure
\end_layout

\begin_layout Subsection
From serial to parallel computing
\end_layout

\begin_layout Standard
For many years the speed of majority of computer programs could be improved
 by upgrading the hardware on which the program was run.
 Ie.
 
\begin_inset Quotes eld
\end_inset

Frequency scaling was the dominant reason for improvements in computer performan
ce from the mid-1980s until 2004.
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-paral"

\end_inset

Therefore, the standard practice has been to write software for serial computati
on meaning that: 
\begin_inset CommandInset citation
LatexCommand cite
key "intro-to-paral"

\end_inset


\end_layout

\begin_layout Itemize
Software is run on a single computer on a single processor (core) 
\end_layout

\begin_layout Itemize
Only one instruction may execute at any moment in time.
 
\end_layout

\begin_layout Itemize
Instructions are executed one after another.
 
\end_layout

\begin_layout Standard
Moore's law states that the number of transistors that can be placed in
 an integrated circuit doubles approximately every two years.
 The trend started in 1958 and is expected to continue until 2015 or 2020
 or later.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-moore"

\end_inset

 The extra transistors cannot be used for increasing the frequency of the
 microprocessor, but they can be used for adding new processor cores for
 parallel computing 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-paral"

\end_inset

.
\end_layout

\begin_layout Subsection
Problems caused by imperative programming paradigm
\end_layout

\begin_layout Standard
As stated earlier, by avoiding mutable state there is no need for locking
 and threads cannot interfere with each other.
 Let's take a look at two common concurrency issues.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset


\emph on
A deadlock
\emph default
 occurs when two threads each lock a different variable at the same time
 and then try to lock the variable that the other thread already locked.
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "ms-deadlock"

\end_inset


\end_layout

\begin_layout Itemize

\emph on
\begin_inset Quotes eld
\end_inset

Race condition
\emph default
 occurs when two threads access a shared variable at the same time.
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "ms-deadlock"

\end_inset

 
\end_layout

\begin_layout Standard
As we can see these issues are not necessarily related to the underlying
 problem we are trying to solve.
 They are mere implementation details.
\end_layout

\begin_layout Subsection
Simple things should be simple
\end_layout

\begin_layout Standard
Clojure has concurrency features built-in.
 Immutable data structures and pure functions enable trivially easy parallel
 processing of functions as long as there is no data dependency between
 them.
\end_layout

\begin_layout Standard
A simple example of easy parallel execution of functions using pmap, a parallel
 map implementation:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(pmap (fn [x] (+ x 2)) '(1 2 3))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There is no need for explicitly spawning new threads nor is there fear for
 race conditions or deadlocks since the function does not rely on external
 state or mutate anything.
\end_layout

\begin_layout Subsection
Reference types
\end_layout

\begin_layout Itemize
atom, agent and ref
\end_layout

\begin_layout Itemize
identity and equality
\end_layout

\begin_layout Subsection
Software transactional memory system (STM)
\end_layout

\begin_layout Itemize
refs require a transaction
\end_layout

\begin_layout Subsection
Example: Java vs.
 Clojure
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "clojure"
options "bibtotoc,abbrvurl"

\end_inset


\end_layout

\end_body
\end_document
