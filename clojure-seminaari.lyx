#LyX 1.6.9 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass docbook
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 0
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Clojure
\end_layout

\begin_layout Date
23.03.2011
\end_layout

\begin_layout Author
\begin_inset Flex Element:Firstname
status collapsed

\begin_layout Plain Layout
Tarmo
\end_layout

\end_inset


\begin_inset Flex Element:Surname
status collapsed

\begin_layout Plain Layout
Aidantausta
\end_layout

\end_inset


\end_layout

\begin_layout Author
\begin_inset Flex Element:Firstname
status collapsed

\begin_layout Plain Layout
Tero
\end_layout

\end_inset


\begin_inset Flex Element:Surname
status collapsed

\begin_layout Plain Layout
Kadenius
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
Clojure is a lisp.
\end_layout

\begin_layout Section
Clojure
\end_layout

\begin_layout Subsection
Wut is Clojure?
\end_layout

\begin_layout Standard
Shortly Clojure, a dialect of Lisp, is a dynamically typed functional programmin
g language hosted on virtual machines like JVM and CLR.
\end_layout

\begin_layout Subsubsection
Dialect of Lisp
\end_layout

\begin_layout Code
(= 2 (+ 1 1))
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

Lisp is a family of computer programming languages based on formal functional
 calculus.
 Lisp (for "List Processing Language") stores and manipulates programs in
 the same manner as any other data, making it well suited for "meta-programming"
 applications.
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "lisp-wikiquote"

\end_inset


\end_layout

\begin_layout Subsubsection
Dynamic typing
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

In a
\emph on
 dynamically typed 
\emph default
language, values have fixed types, but variables and expressions have no
 fixed types.
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "watt-04"

\end_inset


\end_layout

\begin_layout Subsubsection
Functional programming
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

In functional programming, the model of computation is the application of
 functions to arguments.
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "watt-04"

\end_inset


\end_layout

\begin_layout Subsection
Key features
\end_layout

\begin_layout Standard
What makes Clojure stand out in the pool of new and fancy programming language
 is that it has been developed from the ground up with multithreaded programming
 in mind.
 
\emph on
Immutable data structures
\emph default
, support for 
\emph on
software transactional memory
\emph default
 (STM) with the combination of 
\emph on
functional programming
\emph default
 paradigm give Clojure good tools working with concurrency.
\end_layout

\begin_layout Standard
In addition to a sound concurrency story Clojure also provides dynamic developme
nt environment via Read-Eval-Print-Loop (REPL).
 With REPL you can ...
\end_layout

\begin_layout Subsubsection
Functional vs.
 imperative programming
\end_layout

\begin_layout Subsubsection*
Imperative programming
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

Imperative programming is a programming paradigm that describes computation
 in terms of statements that change a program state.
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "wiki-imp-prg"

\end_inset


\end_layout

\begin_layout Standard
Nearly all machine code implementations are written in imperative style.
 The contents of the memory holds the state and machine language instructions
 modify it.
 Higher-level imperative languages have more advanced features like variables
 and complex statements, but the basic idea remains the same.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-imp-prg"

\end_inset


\end_layout

\begin_layout Subsubsection*
Object oriented programming
\end_layout

\begin_layout Quotation
"The set of values of the attributes of a particular object is called its
 state.
 The object consists of state and the behavior that's defined in the object's
 classes." 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-oo"

\end_inset

 
\end_layout

\begin_layout Standard
Object oriented programming provides a feature called encapsulation.
 Encapsulation prevents users of the object from direcly modifying the data
 that forms the state by providing operations (methods) for doing it.
 This is done in order to ensure the validity of the internal state of the
 object.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-oo-enc"

\end_inset


\end_layout

\begin_layout Standard
In other words, at its heart, object oriented programming tends to be imperative.
 The paradigm itself doesn't enforce it, but that is usually the case.
 
\begin_inset CommandInset citation
LatexCommand cite
key "cloj-state"

\end_inset


\end_layout

\begin_layout Subsubsection*
Functional programming
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

Functional programming has its roots in mathematics.
 Instead of providing instructions for modifying the state of the program,
 functional programming emphasizes the application of functions and avoid
 state and mutable data in general.
 
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "wiki-func"

\end_inset


\end_layout

\begin_layout Subsubsection*
Differences
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features islongtable="true">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row endhead="true">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Characteristic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Imperative approach
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Functional approach
\end_layout

\end_inset
</cell>
</row>
<row endfirsthead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Programmer focus
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
How to perform tasks (algorithms) and how to track changes in state.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
What information is desired and what transformations are required.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
State changes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Important.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Non-existent.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Order of execution
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Important.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Low importance.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Primary flow control
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Loops, conditionals, and function (method) calls.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Function calls, including recursion.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Primary manipulation unit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instances of structures or classes.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Functions as first-class objects and data collections.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection*
Critique
\end_layout

\begin_layout Standard
The proponents of functional programming claim that imperative programming
 is flawed.
 First of all, there is an argument that the world doesn't function in a
 way imperative programming models it.
 When dealing with mutable state, the "world" has to stop in order it be
 examined or changed.
 This becomes a major problem when bringing concurrent programming to the
 picture.
 
\begin_inset CommandInset citation
LatexCommand cite
key "cloj-state"

\end_inset


\end_layout

\begin_layout Section
Concurrency/parallelism in Clojure
\end_layout

\begin_layout Subsection
Reference types
\end_layout

\begin_layout Itemize
atom, agent and ref
\end_layout

\begin_layout Itemize
identity and equality
\end_layout

\begin_layout Subsection
Software transactional memory system (STM)
\end_layout

\begin_layout Itemize
refs require a transaction
\end_layout

\begin_layout Subsection
Example: Java vs.
 Clojure
\end_layout

\begin_layout Section
References
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "clojure"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
