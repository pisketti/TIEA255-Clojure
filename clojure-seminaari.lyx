#LyX 1.6.8 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass docbook
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 0
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Clojure
\end_layout

\begin_layout Date
23.03.2011
\end_layout

\begin_layout Author
\begin_inset Flex Element:Firstname
status collapsed

\begin_layout Plain Layout
Tarmo
\end_layout

\end_inset


\begin_inset Flex Element:Surname
status collapsed

\begin_layout Plain Layout
Aidantausta
\end_layout

\end_inset


\end_layout

\begin_layout Author
\begin_inset Flex Element:Firstname
status collapsed

\begin_layout Plain Layout
Tero
\end_layout

\end_inset


\begin_inset Flex Element:Surname
status collapsed

\begin_layout Plain Layout
Kadenius
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
Clojure is a lisp.
\end_layout

\begin_layout Section
What is Clojure?
\end_layout

\begin_layout Standard
Shortly Clojure, a dialect of Lisp, is a dynamically typed functional programmin
g language hosted on virtual machines like JVM and CLR.
\end_layout

\begin_layout Subsubsection
Dialect of Lisp
\end_layout

\begin_layout Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(= 2 (+ 1 1))
\end_layout

\end_inset


\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

Lisp is a family of computer programming languages based on formal functional
 calculus.
 Lisp (for "List Processing Language") stores and manipulates programs in
 the same manner as any other data, making it well suited for "meta-programming"
 applications.
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "lisp-wikiquote"

\end_inset


\end_layout

\begin_layout Subsubsection
Dynamic typing
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

In a
\emph on
 dynamically typed 
\emph default
language, values have fixed types, but variables and expressions have no
 fixed types.
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "watt-04"

\end_inset


\end_layout

\begin_layout Subsubsection
Functional programming
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

In functional programming, the model of computation is the application of
 functions to arguments.
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "watt-04"

\end_inset


\end_layout

\begin_layout Subsection
Key features
\end_layout

\begin_layout Standard
What makes Clojure stand out in the pool of new and fancy programming language
 is that it has been developed from the ground up with multithreaded programming
 in mind.
 
\emph on
Immutable data structures
\emph default
, support for 
\emph on
software transactional memory
\emph default
 (STM) with the combination of 
\emph on
functional programming
\emph default
 paradigm give Clojure good tools working with concurrency.
\end_layout

\begin_layout Standard
In addition to a sound concurrency story Clojure also provides dynamic developme
nt environment via Read-Eval-Print-Loop (REPL).
 With REPL you can ...
\end_layout

\begin_layout Section
Functional vs.
 imperative programming
\end_layout

\begin_layout Subsection
Imperative programming
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

Imperative programming is a programming paradigm that describes computation
 in terms of statements that change a program state.
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "wiki-imp-prg"

\end_inset


\end_layout

\begin_layout Standard
Nearly all machine code implementations are written in imperative style.
 The contents of the memory holds the state and machine language instructions
 modify it.
 Higher-level imperative languages have more advanced features like variables
 and complex statements, but the basic idea remains the same.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-imp-prg"

\end_inset


\end_layout

\begin_layout Subsection
Object oriented programming
\end_layout

\begin_layout Quotation
"The set of values of the attributes of a particular object is called its
 state.
 The object consists of state and the behavior that's defined in the object's
 classes." 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-oo"

\end_inset

 
\end_layout

\begin_layout Standard
Object oriented programming provides a feature called encapsulation.
 Encapsulation prevents users of the object from direcly modifying the data
 that forms the state by providing operations (methods) for doing it.
 This is done in order to ensure the validity of the internal state of the
 object.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-oo-enc"

\end_inset


\end_layout

\begin_layout Standard
In other words, at its heart, object oriented programming tends to be imperative.
 The paradigm itself doesn't enforce it, but that is usually the case.
 
\begin_inset CommandInset citation
LatexCommand cite
key "cloj-state"

\end_inset


\end_layout

\begin_layout Subsection
Functional programming
\end_layout

\begin_layout Quotation
\begin_inset Quotes eld
\end_inset

Functional programming has its roots in mathematics.
 Instead of providing instructions for modifying the state of the program,
 functional programming emphasizes the application of functions and avoid
 state and mutable data in general.
 
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "wiki-func"

\end_inset

 
\end_layout

\begin_layout Subsubsection
Functions as first class objects
\end_layout

\begin_layout Standard
The notion of a function is not unique to functional programming languages.
 However, functional languages have what is called 
\emph on
first class functions
\emph default
.
 This means that functions have a central role in the code, much like objects
 do in OO languages.
 Functions can be stored to data structures and the use of 
\emph on
higher-order functions
\emph default
 is common.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-1st-class-fn"

\end_inset

 The objective of having no side effects manifests itself in 
\emph on
pure functions
\emph default
.
 
\end_layout

\begin_layout Standard
Function is considered pure if:
\end_layout

\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset

The function always evaluates the same result value given the same argument
 value(s).
 The function result value cannot depend on any hidden information or state
 that may change as program execution proceeds or between different executions
 of the program, nor can it depend on any external input from I/O devices.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-pure-fn"

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset

Evaluation of the result does not cause any semantically observable side
 effect or output, such as mutation of mutable objects or output to I/O
 devices.
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-pure-fn"

\end_inset


\end_layout

\begin_layout Standard
Using pure functions has several benefits: 
\end_layout

\begin_layout Enumerate
Pure expression can be removed without affecting other expression if the
 result of the pure expression is not used.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-func"

\end_inset

 
\end_layout

\begin_layout Enumerate

\emph on
Referential transparency
\emph default
.
 An expression can be replaced with its value without causing changes to
 the program.
 The output is always the same with the same input.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-reftrans"

\end_inset


\end_layout

\begin_layout Enumerate
If a pure function does not depend on the result of another pure function,
 they can be performed in any order.
 Ie.
 they are thread-safe and can be run in parallel without typical concurrency
 issues.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-func"

\end_inset

 
\end_layout

\begin_layout Enumerate
Lack of side effects guaranteed by the language, provides opportunities
 for compiler optimizations.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-func"

\end_inset

 
\end_layout

\begin_layout Subsubsection
Higher-order functions
\end_layout

\begin_layout Standard
Higher-order function is a function that either takes one or more functions
 as parameters or returns one as a value.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-higher-fn"

\end_inset

 Well-known examples of higher-order functions are 
\emph on
map
\emph default
 and 
\emph on
fold
\emph default
 
\shape italic

\begin_inset CommandInset citation
LatexCommand cite
key "wiki-fold"

\end_inset

.

\shape default
 
\begin_inset Quotes eld
\end_inset

Map is the name of a higher-order function that applies a given function
 element-wise to a list of elements and returns a list of results.
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-map"

\end_inset

.
 Fold is a 
\begin_inset Quotes eld
\end_inset

function that iterate an arbitrary function over a data structure in some
 order and build up a return value
\begin_inset Quotes erd
\end_inset

.
 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki-fold"

\end_inset


\end_layout

\begin_layout Itemize
Doubling the value of every item in a list with map:
\emph on

\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(map (fn [x] (* x 2)) '(1 2 3))
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
In Clojure fold is called reduce.
 A trivial example for calculating the sum of the items in a list: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(reduce + '(1 2 3))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In addition or rather as a result, functional programming has some interesting
 features.
\end_layout

\begin_layout Subsection
Differences
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features islongtable="true">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row endhead="true">
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Characteristic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Imperative approach
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Functional approach
\end_layout

\end_inset
</cell>
</row>
<row endfirsthead="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Programmer focus
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
How to perform tasks (algorithms) and how to track changes in state.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
What information is desired and what transformations are required.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
State changes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Important.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Non-existent.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Order of execution
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Important.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Low importance.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Primary flow control
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Loops, conditionals, and function (method) calls.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Function calls, including recursion.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Primary manipulation unit
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Instances of structures or classes.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Functions as first-class objects and data collections.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Critique
\end_layout

\begin_layout Standard
The proponents of functional programming claim that imperative programming
 is flawed.
 First of all, there is an argument that the world doesn't function in a
 way imperative programming models it.
 When dealing with mutable state, the "world" has to stop in order it be
 examined or changed.
 This becomes a major problem when bringing concurrent programming to the
 picture.
 
\begin_inset CommandInset citation
LatexCommand cite
key "cloj-state"

\end_inset


\end_layout

\begin_layout Standard
To quote Rich Hickey, the creator of Clojure: "Encapsulation just means:
 I'm in charge of this spaghetti code."
\end_layout

\begin_layout Itemize
Lisp
\end_layout

\begin_deeper
\begin_layout Itemize
Dynamically typed
\end_layout

\begin_layout Itemize
Homoiconic
\end_layout

\begin_deeper
\begin_layout Itemize
Code as data.
 Data as code.
\end_layout

\begin_layout Itemize
meta programming.
 Advanced macros.
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Immutable data structures
\end_layout

\begin_layout Section
Clojure 101
\end_layout

\begin_layout Subsubsection
Lispy syntax
\end_layout

\begin_layout Subsubsection*
Parentheses, parentheses, parentheses
\end_layout

\begin_layout Subsubsection*
Prexi vs.
 Infix notation
\end_layout

\begin_layout Subsubsection
Defining functions
\end_layout

\begin_layout Section
Concurrency/parallelism in Clojure
\end_layout

\begin_layout Subsection
Reference types
\end_layout

\begin_layout Itemize
atom, agent and ref
\end_layout

\begin_layout Itemize
identity and equality
\end_layout

\begin_layout Subsection
Software transactional memory system (STM)
\end_layout

\begin_layout Itemize
refs require a transaction
\end_layout

\begin_layout Subsection
Example: Java vs.
 Clojure
\end_layout

\begin_layout Section
References
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "clojure"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
